"use client";

import React, { useState, useEffect, useRef, useCallback } from "react";

/** --------- Types --------- */
type Settings = {
  particleCount: number;
  velocityCap: number;
  repulsionRadius: number;
  attractionRadius: number;
  cohesionForce: number;
  friction: number;
  randomForce: number;
  rotationSpeed: number;
  trailOpacity: number;
  backgroundColor: string;
  swarmColor: string;
  shape: "circle" | "square" | "line" | "customSVG";
  svgPathData: string;
};

type PresetMap = Record<string, Settings>;

/** --------- Local Storage Helpers --------- */
const LS_KEY = "swarm_presets_v1";

function loadPresetMap(): PresetMap {
  try {
    const raw = localStorage.getItem(LS_KEY);
    return raw ? (JSON.parse(raw) as PresetMap) : {};
  } catch {
    return {};
  }
}

function savePresetMap(map: PresetMap) {
  localStorage.setItem(LS_KEY, JSON.stringify(map));
}

/** --------- Component --------- */
const SwarmApp = () => {
  // Simulation settings state
  const [particleCount, setParticleCount] = useState(2222);
  const [velocityCap, setVelocityCap] = useState(1.5);
  const [repulsionRadius, setRepulsionRadius] = useState(40.0);
  const [attractionRadius, setAttractionRadius] = useState(120.0);
  const [cohesionForce, setCohesionForce] = useState(0.005);
  const [friction, setFriction] = useState(0.98);
  const [randomForce, setRandomForce] = useState(0.01);
  const [rotationSpeed, setRotationSpeed] = useState(0.02);
  const [trailOpacity, setTrailOpacity] = useState(0.05);
  const [backgroundColor, setBackgroundColor] = useState("#000000");
  const [swarmColor, setSwarmColor] = useState("#FF69B4");
  const [shape, setShape] = useState<Settings["shape"]>("line");
  const [svgPathData, setSvgPathData] = useState("M0 -1 L1 0 L0 1");
  const [svgError, setSvgError] = useState("");

  // UI state
  const [isSaving, setIsSaving] = useState(false);
  const [isMessageVisible, setIsMessageVisible] = useState(false);
  const [message, setMessage] = useState("");
  const [presetName, setPresetName] = useState("");
  const [presets, setPresets] = useState<{ id: string }[]>([]);
  const [randomizerOptions, setRandomizerOptions] = useState({
    particleCount: true,
    velocityCap: true,
    repulsionRadius: true,
    attractionRadius: true,
    cohesionForce: true,
    friction: true,
    randomForce: true,
    rotationSpeed: true,
    trailOpacity: true,
    backgroundColor: true,
    swarmColor: true,
    shape: true,
    svgPathData: true,
  });

  // Canvas and animation state
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const particles = useRef<
    { x: number; y: number; vx: number; vy: number; rotation: number }[]
  >([]);
  const animationFrameId = useRef<number | null>(null);
  const customSVGPath2D = useRef<Path2D | null>(null);

  /** ------- Messaging ------- */
  const showMessage = (msg: string, duration = 3000) => {
    setMessage(msg);
    setIsMessageVisible(true);
    window.setTimeout(() => setIsMessageVisible(false), duration);
  };

  /** ------- Presets: storage API (no backend) ------- */
  const currentSettings = useCallback((): Settings => {
    return {
      particleCount,
      velocityCap,
      repulsionRadius,
      attractionRadius,
      cohesionForce,
      friction,
      randomForce,
      rotationSpeed,
      trailOpacity,
      backgroundColor,
      swarmColor,
      shape,
      svgPathData,
    };
  }, [
    particleCount,
    velocityCap,
    repulsionRadius,
    attractionRadius,
    cohesionForce,
    friction,
    randomForce,
    rotationSpeed,
    trailOpacity,
    backgroundColor,
    swarmColor,
    shape,
    svgPathData,
  ]);

  const applyPreset = useCallback((settings: Settings) => {
    setParticleCount(settings.particleCount);
    setVelocityCap(settings.velocityCap);
    setRepulsionRadius(settings.repulsionRadius);
    setAttractionRadius(settings.attractionRadius);
    setCohesionForce(settings.cohesionForce);
    setFriction(settings.friction);
    setRandomForce(settings.randomForce);
    setRotationSpeed(settings.rotationSpeed);
    setTrailOpacity(settings.trailOpacity);
    setBackgroundColor(settings.backgroundColor);
    setSwarmColor(settings.swarmColor);
    setShape(settings.shape);
    setSvgPathData(settings.svgPathData);
  }, []);

  const refreshPresetList = () => {
    const map = loadPresetMap();
    const ids = Object.keys(map).sort((a, b) => a.localeCompare(b));
    setPresets(ids.map((id) => ({ id })));
  };

  // Initial load: get presets; if a "default" preset exists, load it
  useEffect(() => {
    refreshPresetList();
    const map = loadPresetMap();
    if (map.default) {
      applyPreset(map.default);
      showMessage("Loaded default preset.");
    }
  }, [applyPreset]);

  const saveSettings = useCallback(async () => {
    if (!presetName.trim()) {
      showMessage("Please enter a preset name.");
      return;
    }
    setIsSaving(true);
    try {
      const map = loadPresetMap();
      map[presetName.trim()] = currentSettings();
      savePresetMap(map);
      refreshPresetList();
      setPresetName("");
      showMessage(`Preset "${presetName}" saved!`);
    } catch {
      showMessage("Error saving preset.");
    } finally {
      setIsSaving(false);
    }
  }, [presetName, currentSettings]);

  const loadPreset = useCallback((id: string) => {
    const map = loadPresetMap();
    const p = map[id];
    if (p) {
      applyPreset(p);
      showMessage(`Loaded preset: ${id}`);
    } else {
      showMessage("Preset not found.");
    }
  }, [applyPreset]);

  const deletePreset = useCallback((id: string) => {
    const map = loadPresetMap();
    if (map[id]) {
      delete map[id];
      savePresetMap(map);
      refreshPresetList();
      showMessage(`Preset "${id}" deleted.`);
    }
  }, []);

  const exportPresets = () => {
    const map = loadPresetMap();
    const blob = new Blob([JSON.stringify(map, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "swarm-presets.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  const importPresets = async (file: File | null) => {
    if (!file) return;
    try {
      const text = await file.text();
      const incoming = JSON.parse(text) as PresetMap;
      const map = loadPresetMap();
      // Merge (incoming overwrites existing names)
      const merged: PresetMap = { ...map, ...incoming };
      savePresetMap(merged);
      refreshPresetList();
      showMessage("Presets imported.");
    } catch {
      showMessage("Import failed. Not a valid JSON presets file.");
    }
  };

  /** ------- SVG Path validation ------- */
  const handleSvgChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const pathData = e.target.value;
    setSvgPathData(pathData);
    try {
      new Path2D(pathData);
      setSvgError("");
    } catch {
      setSvgError("Invalid SVG path data. Example: M0 -1 L1 0 L0 1");
    }
  };

  useEffect(() => {
    if (shape === "customSVG") {
      try {
        const path = new Path2D(svgPathData);
        customSVGPath2D.current = path;
        setSvgError("");
      } catch {
        customSVGPath2D.current = null;
        setSvgError("Invalid SVG path data. Example: M0 -1 L1 0 L0 1");
      }
    }
  }, [shape, svgPathData]);

  /** ------- Randomize ------- */
  const randomizeSettings = useCallback(() => {
    const randHex = () =>
      "#" +
      Math.floor(Math.random() * 16777215)
        .toString(16)
        .padStart(6, "0");

    const newSettings: Settings = {
      particleCount: randomizerOptions.particleCount
        ? Math.floor(Math.random() * 4000) + 1000
        : particleCount,
      velocityCap: randomizerOptions.velocityCap
        ? Math.random() * 2 + 0.5
        : velocityCap,
      repulsionRadius: randomizerOptions.repulsionRadius
        ? Math.random() * 80 + 20
        : repulsionRadius,
      attractionRadius: randomizerOptions.attractionRadius
        ? Math.random() * 200 + 80
        : attractionRadius,
      cohesionForce: randomizerOptions.cohesionForce
        ? Math.random() * 0.01 + 0.001
        : cohesionForce,
      friction: randomizerOptions.friction ? Math.random() * 0.1 + 0.9 : friction,
      randomForce: randomizerOptions.randomForce
        ? Math.random() * 0.02 + 0.005
        : randomForce,
      rotationSpeed: randomizerOptions.rotationSpeed
        ? Math.random() * 0.05
        : rotationSpeed,
      trailOpacity: randomizerOptions.trailOpacity
        ? Math.random() * 0.1
        : trailOpacity,
      backgroundColor: randomizerOptions.backgroundColor
        ? randHex()
        : backgroundColor,
      swarmColor: randomizerOptions.swarmColor ? randHex() : swarmColor,
      shape: randomizerOptions.shape
        ? (["circle", "square", "line", "customSVG"][
            Math.floor(Math.random() * 4)
          ] as Settings["shape"])
        : shape,
      svgPathData: randomizerOptions.svgPathData
        ? `M${Math.random() * 2} ${Math.random() * 2} L${
            Math.random() * 2
          } ${Math.random() * 2} L${Math.random() * 2} ${Math.random() * 2}`
        : svgPathData,
    };

    applyPreset(newSettings);
  }, [
    randomizerOptions,
    particleCount,
    velocityCap,
    repulsionRadius,
    attractionRadius,
    cohesionForce,
    friction,
    randomForce,
    rotationSpeed,
    trailOpacity,
    backgroundColor,
    swarmColor,
    shape,
    svgPathData,
    applyPreset,
  ]);

  /** ------- Canvas & Animation ------- */
  useEffect(() => {
    const canvas = canvasRef.current!;
    const ctx = canvas.getContext("2d")!;
    let dpr = window.devicePixelRatio || 1;
    let width = 0,
      height = 0;

    const resizeCanvas = () => {
      dpr = window.devicePixelRatio || 1;
      width = canvas.parentElement!.clientWidth;
      height = canvas.parentElement!.clientHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
    };

    const initParticles = () => {
      particles.current = Array.from({ length: particleCount }, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0,
        vy: 0,
        rotation: Math.random() * Math.PI * 2,
      }));
    };

    const draw = () => {
      // background trail fade
      const r = parseInt(backgroundColor.slice(1, 3), 16);
      const g = parseInt(backgroundColor.slice(3, 5), 16);
      const b = parseInt(backgroundColor.slice(5, 7), 16);
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${trailOpacity})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < particles.current.length; i++) {
        const p1 = particles.current[i];
        let fx = 0,
          fy = 0;

        for (let j = 0; j < particles.current.length; j++) {
          if (i === j) continue;
          const p2 = particles.current[j];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const d = Math.hypot(dx, dy);

          if (d > 0) {
            if (d < repulsionRadius) {
              const repul = (repulsionRadius - d) / repulsionRadius;
              fx -= (dx / d) * repul;
              fy -= (dy / d) * repul;
            } else if (d < attractionRadius) {
              const attr = (d - repulsionRadius) / (attractionRadius - repulsionRadius);
              fx += (dx / d) * attr * cohesionForce;
              fy += (dy / d) * attr * cohesionForce;
            }
          }
        }

        // Apply forces + random jitter
        p1.vx += fx + (Math.random() - 0.5) * randomForce;
        p1.vy += fy + (Math.random() - 0.5) * randomForce;

        // Friction (damping)
        p1.vx *= friction;
        p1.vy *= friction;

        // Velocity cap
        const speed = Math.hypot(p1.vx, p1.vy);
        if (speed > velocityCap) {
          const ratio = velocityCap / speed;
          p1.vx *= ratio;
          p1.vy *= ratio;
        }

        p1.x += p1.vx;
        p1.y += p1.vy;
        p1.rotation += rotationSpeed;

        // Wrap
        if (p1.x < 0) p1.x += width;
        if (p1.x > width) p1.x -= width;
        if (p1.y < 0) p1.y += height;
        if (p1.y > height) p1.y -= height;

        // Draw
        ctx.fillStyle = swarmColor;
        ctx.save();
        ctx.translate(p1.x * dpr, p1.y * dpr);
        ctx.rotate(p1.rotation);

        const size = dpr;
        if (shape === "circle") {
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, Math.PI * 2);
          ctx.fill();
        } else if (shape === "square") {
          ctx.fillRect(-size, -size, size * 2, size * 2);
        } else if (shape === "line") {
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, -size * 4);
          ctx.strokeStyle = swarmColor;
          ctx.lineWidth = size * 0.5;
          ctx.stroke();
        } else if (shape === "customSVG" && customSVGPath2D.current) {
          ctx.scale(size * 5, size * 5);
          ctx.fill(customSVGPath2D.current);
        }
        ctx.restore();
      }

      animationFrameId.current = requestAnimationFrame(draw);
    };

    resizeCanvas();
    initParticles();
    window.addEventListener("resize", resizeCanvas);
    animationFrameId.current = requestAnimationFrame(draw);

    return () => {
      window.removeEventListener("resize", resizeCanvas);
      if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    particleCount,
    velocityCap,
    repulsionRadius,
    attractionRadius,
    cohesionForce,
    friction,
    randomForce,
    rotationSpeed,
    trailOpacity,
    backgroundColor,
    swarmColor,
    shape,
    svgPathData,
  ]);

  /** ------- Controls ------- */
  const SliderControl = ({
    label,
    value,
    min,
    max,
    step,
    onChange,
    isRandomizable,
    onRandomizeToggle,
  }: {
    label: string;
    value: number;
    min: number;
    max: number;
    step: number;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    isRandomizable: boolean;
    onRandomizeToggle: () => void;
  }) => (
    <div className="mb-4">
      <div className="flex justify-between items-center mb-1">
        <label className="text-sm font-medium text-gray-400">{label}</label>
        <div className="flex items-center">
          <input
            type="checkbox"
            checked={isRandomizable}
            onChange={onRandomizeToggle}
            className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300"
          />
          <span className="ml-2 text-xs text-gray-500">Randomize</span>
        </div>
      </div>
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={onChange}
        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg [&::-webkit-slider-thumb]:bg-indigo-600 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:-mt-1"
      />
      <span className="text-xs text-gray-500 float-right mt-1">
        {value.toFixed(3)}
      </span>
    </div>
  );

  return (
    <>
      {/* Canvas */}
      <div className="relative bg-black h-full w-full">
        <canvas ref={canvasRef} className="w-full h-full" />
      </div>

      {/* Control Panel */}
      <div className="bg-zinc-900 w-full lg:w-96 flex-shrink-0 p-6 overflow-y-auto border-l border-zinc-700">
        <h1 className="text-3xl font-bold mb-6 text-yellow-300">Swarm Controls</h1>

        {/* Preset Actions */}
        <div className="mb-8">
          <h2 className="text-xl font-semibold mb-3 text-white">Presets</h2>
          <div className="flex space-x-2 mb-4">
            <input
              type="text"
              value={presetName}
              onChange={(e) => setPresetName(e.target.value)}
              placeholder="Enter preset name"
              className="flex-1 px-3 py-2 bg-zinc-800 rounded-lg text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
            <button
              onClick={saveSettings}
              disabled={isSaving}
              className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-green-400"
            >
              Save
            </button>
          </div>

          <div className="flex items-center gap-2 mb-3">
            <button
              onClick={exportPresets}
              className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold py-2 px-3 rounded"
            >
              Export All
            </button>
            <label className="text-xs text-white bg-zinc-800 hover:bg-zinc-700 py-2 px-3 rounded cursor-pointer">
              Import
              <input
                type="file"
                accept="application/json"
                className="hidden"
                onChange={(e) => importPresets(e.target.files?.[0] ?? null)}
              />
            </label>
          </div>

          <div className="space-y-2 max-h-48 overflow-y-auto">
            {presets.length > 0 ? (
              presets.map((p) => (
                <div
                  key={p.id}
                  className="flex items-center justify-between bg-zinc-800 p-3 rounded-lg"
                >
                  <span className="text-sm truncate">{p.id}</span>
                  <div className="flex space-x-2">
                    <button
                      onClick={() => loadPreset(p.id)}
                      className="text-indigo-400 hover:text-indigo-300 text-xs"
                    >
                      Load
                    </button>
                    <button
                      onClick={() => deletePreset(p.id)}
                      className="text-red-400 hover:text-red-300 text-xs"
                    >
                      Delete
                    </button>
                  </div>
                </div>
              ))
            ) : (
              <p className="text-sm text-gray-500">No presets saved yet.</p>
            )}
          </div>
        </div>

        {/* Randomization */}
        <div className="flex justify-center mb-8">
          <button
            onClick={randomizeSettings}
            className="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:scale-105"
          >
            Randomize Selected
          </button>
        </div>

        {/* Sliders */}
        <div className="flex flex-col space-y-4">
          <SliderControl
            label="Particle Count"
            value={particleCount}
            min={1}
            max={1222}
            step={25}
            onChange={(e) => setParticleCount(Number(e.target.value))}
            isRandomizable={randomizerOptions.particleCount}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                particleCount: !randomizerOptions.particleCount,
              })
            }
          />
          <SliderControl
            label="Velocity Cap"
            value={velocityCap}
            min={0.1}
            max={5.0}
            step={0.001}
            onChange={(e) => setVelocityCap(Number(e.target.value))}
            isRandomizable={randomizerOptions.velocityCap}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                velocityCap: !randomizerOptions.velocityCap,
              })
            }
          />
          <SliderControl
            label="Repulsion Radius"
            value={repulsionRadius}
            min={1.0}
            max={100.0}
            step={0.001}
            onChange={(e) => setRepulsionRadius(Number(e.target.value))}
            isRandomizable={randomizerOptions.repulsionRadius}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                repulsionRadius: !randomizerOptions.repulsionRadius,
              })
            }
          />
          <SliderControl
            label="Attraction Radius"
            value={attractionRadius}
            min={1.0}
            max={500.0}
            step={0.001}
            onChange={(e) => setAttractionRadius(Number(e.target.value))}
            isRandomizable={randomizerOptions.attractionRadius}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                attractionRadius: !randomizerOptions.attractionRadius,
              })
            }
          />
          <SliderControl
            label="Cohesion Force"
            value={cohesionForce}
            min={0.001}
            max={1}
            step={0.0001}
            onChange={(e) => setCohesionForce(Number(e.target.value))}
            isRandomizable={randomizerOptions.cohesionForce}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                cohesionForce: !randomizerOptions.cohesionForce,
              })
            }
          />
          <SliderControl
            label="Friction"
            value={friction}
            min={1}
            max={0.999}
            step={0.001}
            onChange={(e) => setFriction(Number(e.target.value))}
            isRandomizable={randomizerOptions.friction}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                friction: !randomizerOptions.friction,
              })
            }
          />
          <SliderControl
            label="Random Force"
            value={randomForce}
            min={0.001}
            max={0.1}
            step={0.001}
            onChange={(e) => setRandomForce(Number(e.target.value))}
            isRandomizable={randomizerOptions.randomForce}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                randomForce: !randomizerOptions.randomForce,
              })
            }
          />
          <SliderControl
            label="Rotation Speed"
            value={rotationSpeed}
            min={0.0}
            max={0.2}
            step={0.001}
            onChange={(e) => setRotationSpeed(Number(e.target.value))}
            isRandomizable={randomizerOptions.rotationSpeed}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                rotationSpeed: !randomizerOptions.rotationSpeed,
              })
            }
          />
          <SliderControl
            label="Trail Opacity"
            value={trailOpacity}
            min={0.0}
            max={1.0}
            step={0.001}
            onChange={(e) => setTrailOpacity(Number(e.target.value))}
            isRandomizable={randomizerOptions.trailOpacity}
            onRandomizeToggle={() =>
              setRandomizerOptions({
                ...randomizerOptions,
                trailOpacity: !randomizerOptions.trailOpacity,
              })
            }
          />

          {/* Colors */}
          <div className="mb-4">
            <div className="flex justify-between items-center mb-1">
              <label className="text-sm font-medium text-gray-400">
                Background Color
              </label>
              <div className="flex items-center">
                <input
                  type="checkbox"
                  checked={randomizerOptions.backgroundColor}
                  onChange={() =>
                    setRandomizerOptions({
                      ...randomizerOptions,
                      backgroundColor: !randomizerOptions.backgroundColor,
                    })
                  }
                  className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300"
                />
                <span className="ml-2 text-xs text-gray-500">Randomize</span>
              </div>
            </div>
            <input
              type="color"
              value={backgroundColor}
              onChange={(e) => setBackgroundColor(e.target.value)}
              className="w-full h-10 appearance-none rounded-lg cursor-pointer"
            />
          </div>

          <div className="mb-4">
            <div className="flex justify-between items-center mb-1">
              <label className="text-sm font-medium text-gray-400">
                Swarm Color
              </label>
              <div className="flex items-center">
                <input
                  type="checkbox"
                  checked={randomizerOptions.swarmColor}
                  onChange={() =>
                    setRandomizerOptions({
                      ...randomizerOptions,
                      swarmColor: !randomizerOptions.swarmColor,
                    })
                  }
                  className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300"
                />
                <span className="ml-2 text-xs text-gray-500">Randomize</span>
              </div>
            </div>
            <input
              type="color"
              value={swarmColor}
              onChange={(e) => setSwarmColor(e.target.value)}
              className="w-full h-10 appearance-none rounded-lg cursor-pointer"
            />
          </div>

          {/* Shape + SVG */}
          <div className="mb-4">
            <div className="flex justify-between items-center mb-1">
              <label className="text-sm font-medium text-gray-400">Shape</label>
              <div className="flex items-center">
                <input
                  type="checkbox"
                  checked={randomizerOptions.shape}
                  onChange={() =>
                    setRandomizerOptions({
                      ...randomizerOptions,
                      shape: !randomizerOptions.shape,
                    })
                  }
                  className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300"
                />
                <span className="ml-2 text-xs text-gray-500">Randomize</span>
              </div>
            </div>
            <select
              value={shape}
              onChange={(e) => setShape(e.target.value as Settings["shape"])}
              className="w-full px-3 py-2 bg-zinc-800 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="line">Line</option>
              <option value="customSVG">Custom SVG</option>
            </select>
          </div>

          {shape === "customSVG" && (
            <div className="mb-4">
              <div className="flex justify-between items-center mb-1">
                <label className="text-sm font-medium text-gray-400">
                  SVG Path
                </label>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={randomizerOptions.svgPathData}
                    onChange={() =>
                      setRandomizerOptions({
                        ...randomizerOptions,
                        svgPathData: !randomizerOptions.svgPathData,
                      })
                    }
                    className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300"
                  />
                  <span className="ml-2 text-xs text-gray-500">Randomize</span>
                </div>
              </div>
              <input
                type="text"
                value={svgPathData}
                onChange={handleSvgChange}
                className="w-full px-3 py-2 bg-zinc-800 rounded-lg text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                placeholder="e.g., M0 -1 L1 0 L0 1"
              />
              {svgError && (
                <p className="text-red-400 text-xs mt-2">{svgError}</p>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Message */}
      <div
        className={`fixed bottom-4 left-1/2 -translate-x-1/2 transform transition-opacity duration-300 p-4 bg-green-500 text-white rounded-lg shadow-xl ${
          isMessageVisible ? "opacity-100" : "opacity-0 pointer-events-none"
        }`}
      >
        {message}
      </div>
    </>
  );
};

export default SwarmApp;
