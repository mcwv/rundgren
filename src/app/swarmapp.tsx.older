"use client";

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { getAuth, signInAnonymously, signInWithCustomToken } from 'firebase/auth';
import { initializeApp } from 'firebase/app';
import { getFirestore, doc, setDoc, onSnapshot } from 'firebase/firestore';

// Main App component
const App = () => {
    // State hooks for all simulation controls and UI elements
    const [particleCount, setParticleCount] = useState(5000);
    const [velocityCap, setVelocityCap] = useState(1.500);
    const [repulsionRadius, setRepulsionRadius] = useState(40.000);
    const [attractionRadius, setAttractionRadius] = useState(120.000);
    const [cohesionForce, setCohesionForce] = useState(0.005);
    const [friction, setFriction] = useState(0.980);
    const [randomForce, setRandomForce] = useState(0.010);
    const [rotationSpeed, setRotationSpeed] = useState(0.020);
    const [trailOpacity, setTrailOpacity] = useState(0.050);
    const [backgroundColor, setBackgroundColor] = useState('#000000');
    const [swarmColor, setSwarmColor] = useState('#FF69B4'); // Default to a nice pink
    const [shape, setShape] = useState('line');
    const [svgPathData, setSvgPathData] = useState('M0 -1 L1 0 L0 1');
    const [svgError, setSvgError] = useState('');
    const [isDarkMode, setIsDarkMode] = useState(true);
    const [isSaving, setIsSaving] = useState(false);
    const [isMessageVisible, setIsMessageVisible] = useState(false);
    const [message, setMessage] = useState('');

    // Store particles in state to trigger re-renders and manage their lifecycle
    const [particles, setParticles] = useState([]);

    // Refs for canvas and animation frame ID
    const canvasRef = useRef(null);
    const frameIdRef = useRef();

    // Refs for Firebase and user data
    const dbRef = useRef(null);
    const authRef = useRef(null);
    const userIdRef = useRef(null);
    const isAuthReadyRef = useRef(false);

    // Initial Firebase setup
    useEffect(() => {
        const setupFirebase = async () => {
            try {
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

                if (!firebaseConfig) {
                    console.error("Firebase config is missing.");
                    return;
                }

                // Initialize Firebase app
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);
                dbRef.current = db;
                authRef.current = auth;

                // Sign in with custom token or anonymously
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                // Wait for auth state to be ready
                const authReadyPromise = new Promise(resolve => {
                    const unsubscribe = onAuthStateChanged(auth, user => {
                        if (user) {
                            userIdRef.current = user.uid;
                            isAuthReadyRef.current = true;
                            unsubscribe();
                            resolve();
                        }
                    });
                });
                await authReadyPromise;

                // Listen for changes in the document to load presets
                const docRef = doc(db, 'artifacts', appId, 'users', userIdRef.current, 'presets', 'default');
                onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setParticleCount(data.particleCount ?? 5000);
                        setVelocityCap(data.velocityCap ?? 1.500);
                        setRepulsionRadius(data.repulsionRadius ?? 40.000);
                        setAttractionRadius(data.attractionRadius ?? 120.000);
                        setCohesionForce(data.cohesionForce ?? 0.005);
                        setFriction(data.friction ?? 0.980);
                        setRandomForce(data.randomForce ?? 0.010);
                        setRotationSpeed(data.rotationSpeed ?? 0.020);
                        setTrailOpacity(data.trailOpacity ?? 0.050);
                        setBackgroundColor(data.backgroundColor ?? '#000000');
                        setSwarmColor(data.swarmColor ?? '#FF69B4');
                        setShape(data.shape ?? 'line');
                        setSvgPathData(data.svgPathData ?? 'M0 -1 L1 0 L0 1');
                    }
                });
            } catch (error) {
                console.error("Firebase setup failed:", error);
                showMessage("Failed to set up database.");
            }
        };

        setupFirebase();
    }, []);

    // A particle object constructor
    const Particle = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return null;
        return {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.1,
            vy: (Math.random() - 0.5) * 0.1,
            rotation: 0,
            ax: 0,
            ay: 0,
            color: swarmColor,
        };
    }, [swarmColor]);

    // Main drawing and update loop
    const animate = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Update particle count on the fly
        setParticles(currentParticles => {
            const newParticles = [...currentParticles];
            if (newParticles.length < particleCount) {
                for (let i = newParticles.length; i < particleCount; i++) {
                    const p = Particle();
                    if(p) newParticles.push(p);
                }
            } else if (newParticles.length > particleCount) {
                newParticles.splice(0, newParticles.length - particleCount);
            }
            return newParticles;
        });

        // Semi-transparent background for trailing effect
        ctx.fillStyle = `rgba(${parseInt(backgroundColor.slice(1, 3), 16)}, ${parseInt(backgroundColor.slice(3, 5), 16)}, ${parseInt(backgroundColor.slice(5, 7), 16)}, ${trailOpacity})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update and draw each particle
        setParticles(currentParticles => currentParticles.map((p, pIndex) => {
            // Repulsion and attraction logic
            let totalRepulsionX = 0, totalRepulsionY = 0;
            let totalAttractionX = 0, totalAttractionY = 0;
            let neighborCount = 0;

            currentParticles.forEach((other, otherIndex) => {
                if (pIndex === otherIndex) return;

                const dx = other.x - p.x;
                const dy = other.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < repulsionRadius && dist > 0) {
                    const force = (repulsionRadius - dist) / repulsionRadius;
                    totalRepulsionX -= dx / dist * force;
                    totalRepulsionY -= dy / dist * force;
                }

                if (dist < attractionRadius && dist > 0) {
                    totalAttractionX += dx;
                    totalAttractionY += dy;
                    neighborCount++;
                }
            });

            // Cohesion
            if (neighborCount > 0) {
                p.ax += (totalAttractionX / neighborCount - p.x) * cohesionForce;
                p.ay += (totalAttractionY / neighborCount - p.y) * cohesionForce;
            }

            // Apply forces
            p.ax += totalRepulsionX;
            p.ay += totalRepulsionY;
            p.ax += (Math.random() - 0.5) * randomForce;
            p.ay += (Math.random() - 0.5) * randomForce;

            // Apply acceleration
            p.vx += p.ax;
            p.vy += p.ay;

            // Apply friction
            p.vx *= friction;
            p.vy *= friction;

            // Cap velocity
            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            if (speed > velocityCap) {
                p.vx = (p.vx / speed) * velocityCap;
                p.vy = (p.vy / speed) * velocityCap;
            }

            // Update position
            p.x += p.vx;
            p.y += p.vy;

            // Apply rotation speed
            p.rotation += rotationSpeed;

            // Handle screen edges
            if (p.x < 0) p.x = canvas.width;
            if (p.x > canvas.width) p.x = 0;
            if (p.y < 0) p.y = canvas.height;
            if (p.y > canvas.height) p.y = 0;

            // Draw the particle
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.fillStyle = p.color;
            ctx.strokeStyle = p.color;

            if (shape === 'line') {
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(0, 5);
                ctx.stroke();
            } else if (shape === 'square') {
                ctx.fillRect(-2, -2, 4, 4);
            } else if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape === 'customSvg') {
                try {
                    const path = new Path2D(svgPathData);
                    ctx.scale(20, 20); // Scale up for better visibility
                    ctx.stroke(path);
                } catch (e) {
                    console.error("Invalid SVG path data:", e);
                    setSvgError("Invalid SVG path data.");
                }
            }

            ctx.restore();
            return p;
        }));

        frameIdRef.current = requestAnimationFrame(animate);
    }, [particleCount, velocityCap, repulsionRadius, attractionRadius, cohesionForce, friction, randomForce, rotationSpeed, trailOpacity, backgroundColor, swarmColor, shape, svgPathData, Particle]);

    // Initial setup and animation start
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const resizeCanvas = () => {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            // Re-initialize particles on resize
            setParticles([]);
            const newParticles = [];
            for (let i = 0; i < particleCount; i++) {
                const p = Particle();
                if(p) newParticles.push(p);
            }
            setParticles(newParticles);
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        frameIdRef.current = requestAnimationFrame(animate);

        return () => {
            window.removeEventListener('resize', resizeCanvas);
            cancelAnimationFrame(frameIdRef.current);
        };
    }, [particleCount, animate, Particle]);

    // Helper function to show a message
    const showMessage = (text) => {
        setMessage(text);
        setIsMessageVisible(true);
        setTimeout(() => {
            setIsMessageVisible(false);
        }, 3000);
    };

    // Function to save the current settings to Firestore
    const saveSettings = async () => {
        if (!dbRef.current || !userIdRef.current || !isAuthReadyRef.current) {
            showMessage("Database not ready.");
            return;
        }

        setIsSaving(true);
        try {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = doc(dbRef.current, 'artifacts', appId, 'users', userIdRef.current, 'presets', 'default');
            await setDoc(docRef, {
                particleCount, velocityCap, repulsionRadius, attractionRadius, cohesionForce,
                friction, randomForce, rotationSpeed, trailOpacity, backgroundColor, swarmColor,
                shape, svgPathData
            });
            showMessage("Settings saved!");
        } catch (error) {
            console.error("Failed to save settings:", error);
            showMessage("Failed to save settings.");
        } finally {
            setIsSaving(false);
        }
    };

    // Helper component for sliders
    const SliderControl = ({ label, value, min, max, step, onChange }) => (
        <div className="flex flex-col mb-4 p-3 bg-white/10 rounded-xl shadow-inner">
            <div className="flex justify-between items-center mb-1">
                <label className="text-sm font-medium text-gray-300">{label}</label>
                <span className="text-sm text-gray-400">{value.toFixed(3)}</span>
            </div>
            <input
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer"
            />
        </div>
    );

    // Main UI rendering
    return (
        <div className={`relative min-h-screen font-sans transition-colors duration-500 ${isDarkMode ? 'bg-zinc-950 text-gray-100' : 'bg-gray-100 text-gray-900'}`}>
            {/* Main Canvas Area */}
            <canvas ref={canvasRef} className="absolute inset-0 w-full h-full z-0"></canvas>

            {/* UI Control Panel */}
            <div className={`absolute top-0 right-0 h-full w-full sm:w-80 md:w-96 lg:w-96 xl:w-1/3 2xl:w-1/4 backdrop-blur-md bg-zinc-800/80 p-6 overflow-y-auto transform transition-transform duration-500 ease-in-out ${isDarkMode ? 'text-gray-100' : 'text-gray-800'}`}>
                <div className="flex justify-between items-center mb-6">
                    <h1 className="text-3xl font-bold tracking-tight text-white">Swarm Controls</h1>
                    {/* Dark/Light Mode Toggle */}
                    <button
                        onClick={() => setIsDarkMode(!isDarkMode)}
                        className="p-2 rounded-full bg-white/10 hover:bg-white/20 transition-colors"
                    >
                        {isDarkMode ?
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-sun"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M17.66 6.34l1.41-1.41"/></svg>
                            :
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-moon"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                        }
                    </button>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                    {/* Swarm Movement Controls */}
                    <div className="p-5 bg-zinc-700/50 rounded-2xl shadow-lg">
                        <h2 className="text-xl font-semibold mb-4 text-white">Swarm Movement</h2>
                        <SliderControl label="Particle Count" value={particleCount} min={10} max={10000} step={1} onChange={setParticleCount} />
                        <SliderControl label="Velocity Cap" value={velocityCap} min={0.01} max={5.0} step={0.001} onChange={setVelocityCap} />
                        <SliderControl label="Repulsion Radius" value={repulsionRadius} min={0} max={200} step={0.001} onChange={setRepulsionRadius} />
                        <SliderControl label="Attraction Radius" value={attractionRadius} min={0} max={200} step={0.001} onChange={setAttractionRadius} />
                        <SliderControl label="Cohesion Force" value={cohesionForce} min={0} max={0.1} step={0.001} onChange={setCohesionForce} />
                        <SliderControl label="Friction" value={friction} min={0} max={1} step={0.001} onChange={setFriction} />
                        <SliderControl label="Random Force" value={randomForce} min={0} max={0.1} step={0.001} onChange={setRandomForce} />
                    </div>

                    {/* Appearance Controls */}
                    <div className="p-5 bg-zinc-700/50 rounded-2xl shadow-lg">
                        <h2 className="text-xl font-semibold mb-4 text-white">Appearance & Shape</h2>
                        <SliderControl label="Rotation Speed" value={rotationSpeed} min={0.001} max={0.5} step={0.001} onChange={setRotationSpeed} />
                        <SliderControl label="Trail Opacity" value={trailOpacity} min={0} max={0.2} step={0.001} onChange={setTrailOpacity} />

                        <div className="flex items-center justify-between mb-4 p-3 bg-white/10 rounded-xl shadow-inner">
                            <label className="text-sm font-medium text-gray-300">Swarm Color</label>
                            <input
                                type="color"
                                value={swarmColor}
                                onChange={(e) => setSwarmColor(e.target.value)}
                                className="w-10 h-10 border-none rounded-full cursor-pointer"
                            />
                        </div>
                        <div className="flex items-center justify-between mb-4 p-3 bg-white/10 rounded-xl shadow-inner">
                            <label className="text-sm font-medium text-gray-300">Background Color</label>
                            <input
                                type="color"
                                value={backgroundColor}
                                onChange={(e) => setBackgroundColor(e.target.value)}
                                className="w-10 h-10 border-none rounded-full cursor-pointer"
                            />
                        </div>

                        {/* Shape Selection */}
                        <div className="flex flex-col mb-4 p-3 bg-white/10 rounded-xl shadow-inner">
                            <label className="text-sm font-medium text-gray-300 mb-2">Particle Shape</label>
                            <div className="grid grid-cols-2 gap-2">
                                {['line', 'square', 'circle', 'customSvg'].map(s => (
                                    <button
                                        key={s}
                                        onClick={() => setShape(s)}
                                        className={`p-2 rounded-lg text-sm transition-colors ${shape === s ? 'bg-indigo-600 text-white shadow-lg' : 'bg-zinc-700 text-gray-300 hover:bg-indigo-500 hover:text-white'}`}
                                    >
                                        {s.charAt(0).toUpperCase() + s.slice(1).replace('Svg', ' SVG')}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* SVG Path Input */}
                        {shape === 'customSvg' && (
                            <div className="flex flex-col mb-4 p-3 bg-white/10 rounded-xl shadow-inner">
                                <label className="text-sm font-medium text-gray-300 mb-2">SVG Path Data</label>
                                <input
                                    type="text"
                                    value={svgPathData}
                                    onChange={(e) => setSvgPathData(e.target.value)}
                                    className="w-full p-2 text-sm rounded-lg bg-zinc-800 text-gray-100 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    placeholder="e.g., M0 -1 L1 0 L0 1"
                                />
                                {svgError && <p className="text-red-400 text-xs mt-2">{svgError}</p>}
                            </div>
                        )}
                    </div>
                </div>

                {/* Action Buttons */}
                <div className="sticky bottom-0 bg-zinc-800/80 p-6 -mx-6 mt-6 border-t border-zinc-700 flex justify-center space-x-4">
                    <button
                        onClick={saveSettings}
                        disabled={isSaving}
                        className="flex-1 px-4 py-3 text-lg font-bold rounded-xl text-white bg-indigo-600 hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105 shadow-md disabled:bg-indigo-400 disabled:cursor-not-allowed"
                    >
                        {isSaving ? 'Saving...' : 'Save Settings'}
                    </button>
                </div>
            </div>

            {/* Message Box */}
            <div className={`fixed bottom-4 left-1/2 -translate-x-1/2 transform transition-opacity duration-300 p-4 bg-green-500 text-white rounded-lg shadow-xl ${isMessageVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                {message}
            </div>
        </div>
    );
};

export default App;
